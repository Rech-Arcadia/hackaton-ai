{"ast":null,"code":"import axios from 'axios';\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';\n\n// Configuración global de axios\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 30000,\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// Interceptor para logging y manejo de errores\napi.interceptors.response.use(response => {\n  console.log('API Response:', response.data);\n  return response;\n}, error => {\n  var _error$response;\n  console.error('API Error:', ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) || error.message);\n  return Promise.reject(error);\n});\nexport const paymentService = {\n  /**\r\n   * Verifica el estado del servidor\r\n   */\n  async healthCheck() {\n    try {\n      const response = await api.get('/health');\n      return response.data;\n    } catch (error) {\n      throw new Error('No se pudo conectar con el servidor');\n    }\n  },\n  /**\r\n   * Inicia el proceso de pago\r\n   * @param {Object} paymentData - Datos del pago\r\n   * @param {string} paymentData.receivingWallet - URL del wallet receptor\r\n   * @param {string|number} paymentData.amount - Cantidad a transferir\r\n   * @returns {Promise<Object>} Respuesta con datos de la sesión\r\n   */\n  async initiatePayment(paymentData) {\n    try {\n      const {\n        receivingWallet,\n        amount\n      } = paymentData;\n      if (!receivingWallet || !amount) {\n        throw new Error('Faltan datos requeridos: wallet receptor y cantidad');\n      }\n      if (isNaN(amount) || Number(amount) <= 0) {\n        throw new Error('La cantidad debe ser un número mayor a 0');\n      }\n      const response = await api.post('/initiate-payment', {\n        receivingWallet: receivingWallet.trim(),\n        amount: Number(amount)\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.error || 'Error iniciando el pago');\n      }\n      return response.data;\n    } catch (error) {\n      if (error.response) {\n        var _error$response$data;\n        // Error del servidor\n        throw new Error(((_error$response$data = error.response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.error) || 'Error del servidor');\n      } else if (error.request) {\n        // Error de red\n        throw new Error('Error de conexión. Verifica tu conexión a internet.');\n      } else {\n        // Error de validación u otro\n        throw error;\n      }\n    }\n  },\n  /**\r\n   * Completa el proceso de pago después de la autorización\r\n   * @param {string} sessionId - ID de la sesión de pago\r\n   * @returns {Promise<Object>} Respuesta con resultado del pago\r\n   */\n  async completePayment(sessionId) {\n    try {\n      if (!sessionId) {\n        throw new Error('Se requiere el ID de la sesión');\n      }\n      const response = await api.post('/complete-payment', {\n        sessionId\n      });\n      if (!response.data.success) {\n        throw new Error(response.data.error || 'Error completando el pago');\n      }\n      return response.data;\n    } catch (error) {\n      if (error.response) {\n        var _error$response$data2;\n        throw new Error(((_error$response$data2 = error.response.data) === null || _error$response$data2 === void 0 ? void 0 : _error$response$data2.error) || 'Error completando el pago');\n      } else if (error.request) {\n        throw new Error('Error de conexión al completar el pago');\n      } else {\n        throw error;\n      }\n    }\n  },\n  /**\r\n   * Obtiene el estado de una sesión de pago\r\n   * @param {string} sessionId - ID de la sesión\r\n   * @returns {Promise<Object>} Estado de la sesión\r\n   */\n  async getSessionStatus(sessionId) {\n    try {\n      if (!sessionId) {\n        throw new Error('Se requiere el ID de la sesión');\n      }\n      const response = await api.get(`/session/${sessionId}`);\n      if (!response.data.success) {\n        throw new Error(response.data.error || 'Sesión no encontrada');\n      }\n      return response.data;\n    } catch (error) {\n      var _error$response2;\n      if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 404) {\n        throw new Error('Sesión no encontrada o expirada');\n      } else if (error.response) {\n        var _error$response$data3;\n        throw new Error(((_error$response$data3 = error.response.data) === null || _error$response$data3 === void 0 ? void 0 : _error$response$data3.error) || 'Error obteniendo estado de sesión');\n      } else if (error.request) {\n        throw new Error('Error de conexión');\n      } else {\n        throw error;\n      }\n    }\n  },\n  /**\r\n   * Cancela una sesión de pago\r\n   * @param {string} sessionId - ID de la sesión a cancelar\r\n   * @returns {Promise<Object>} Confirmación de cancelación\r\n   */\n  async cancelSession(sessionId) {\n    try {\n      if (!sessionId) {\n        throw new Error('Se requiere el ID de la sesión');\n      }\n      const response = await api.delete(`/session/${sessionId}`);\n      if (!response.data.success) {\n        throw new Error(response.data.error || 'Error cancelando la sesión');\n      }\n      return response.data;\n    } catch (error) {\n      var _error$response3;\n      if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 404) {\n        // Si la sesión ya no existe, consideramos que está cancelada\n        return {\n          success: true,\n          message: 'Sesión ya cancelada o expirada'\n        };\n      } else if (error.response) {\n        var _error$response$data4;\n        throw new Error(((_error$response$data4 = error.response.data) === null || _error$response$data4 === void 0 ? void 0 : _error$response$data4.error) || 'Error cancelando la sesión');\n      } else if (error.request) {\n        throw new Error('Error de conexión al cancelar');\n      } else {\n        throw error;\n      }\n    }\n  },\n  /**\r\n   * Valida una URL de wallet\r\n   * @param {string} walletUrl - URL a validar\r\n   * @returns {boolean} true si es válida\r\n   */\n  validateWalletUrl(walletUrl) {\n    try {\n      const url = new URL(walletUrl);\n      return url.protocol === 'https:' && url.hostname.includes('interledger');\n    } catch {\n      return false;\n    }\n  },\n  /**\r\n   * Formatea una cantidad para mostrar\r\n   * @param {string|number} amount - Cantidad a formatear\r\n   * @param {string} assetCode - Código de la moneda (opcional)\r\n   * @returns {string} Cantidad formateada\r\n   */\n  formatAmount(amount, assetCode = '') {\n    try {\n      const num = Number(amount);\n      if (isNaN(num)) return amount;\n      return new Intl.NumberFormat('es-ES', {\n        minimumFractionDigits: 0,\n        maximumFractionDigits: 2\n      }).format(num) + (assetCode ? ` ${assetCode}` : '');\n    } catch {\n      return amount.toString();\n    }\n  }\n};\nexport default paymentService;","map":{"version":3,"names":["axios","API_BASE_URL","process","env","REACT_APP_API_URL","api","create","baseURL","timeout","headers","interceptors","response","use","console","log","data","error","_error$response","message","Promise","reject","paymentService","healthCheck","get","Error","initiatePayment","paymentData","receivingWallet","amount","isNaN","Number","post","trim","success","_error$response$data","request","completePayment","sessionId","_error$response$data2","getSessionStatus","_error$response2","status","_error$response$data3","cancelSession","delete","_error$response3","_error$response$data4","validateWalletUrl","walletUrl","url","URL","protocol","hostname","includes","formatAmount","assetCode","num","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","format","toString"],"sources":["C:/Users/unequ/Desktop/1-Hackaton/hackaton-ai/front-end/src/services/paymentService.js"],"sourcesContent":["import axios from 'axios';\r\n\r\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';\r\n\r\n// Configuración global de axios\r\nconst api = axios.create({\r\n  baseURL: API_BASE_URL,\r\n  timeout: 30000,\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n  },\r\n});\r\n\r\n// Interceptor para logging y manejo de errores\r\napi.interceptors.response.use(\r\n  (response) => {\r\n    console.log('API Response:', response.data);\r\n    return response;\r\n  },\r\n  (error) => {\r\n    console.error('API Error:', error.response?.data || error.message);\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\nexport const paymentService = {\r\n  /**\r\n   * Verifica el estado del servidor\r\n   */\r\n  async healthCheck() {\r\n    try {\r\n      const response = await api.get('/health');\r\n      return response.data;\r\n    } catch (error) {\r\n      throw new Error('No se pudo conectar con el servidor');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Inicia el proceso de pago\r\n   * @param {Object} paymentData - Datos del pago\r\n   * @param {string} paymentData.receivingWallet - URL del wallet receptor\r\n   * @param {string|number} paymentData.amount - Cantidad a transferir\r\n   * @returns {Promise<Object>} Respuesta con datos de la sesión\r\n   */\r\n  async initiatePayment(paymentData) {\r\n    try {\r\n      const { receivingWallet, amount } = paymentData;\r\n      \r\n      if (!receivingWallet || !amount) {\r\n        throw new Error('Faltan datos requeridos: wallet receptor y cantidad');\r\n      }\r\n\r\n      if (isNaN(amount) || Number(amount) <= 0) {\r\n        throw new Error('La cantidad debe ser un número mayor a 0');\r\n      }\r\n\r\n      const response = await api.post('/initiate-payment', {\r\n        receivingWallet: receivingWallet.trim(),\r\n        amount: Number(amount)\r\n      });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.error || 'Error iniciando el pago');\r\n      }\r\n\r\n      return response.data;\r\n    } catch (error) {\r\n      if (error.response) {\r\n        // Error del servidor\r\n        throw new Error(error.response.data?.error || 'Error del servidor');\r\n      } else if (error.request) {\r\n        // Error de red\r\n        throw new Error('Error de conexión. Verifica tu conexión a internet.');\r\n      } else {\r\n        // Error de validación u otro\r\n        throw error;\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Completa el proceso de pago después de la autorización\r\n   * @param {string} sessionId - ID de la sesión de pago\r\n   * @returns {Promise<Object>} Respuesta con resultado del pago\r\n   */\r\n  async completePayment(sessionId) {\r\n    try {\r\n      if (!sessionId) {\r\n        throw new Error('Se requiere el ID de la sesión');\r\n      }\r\n\r\n      const response = await api.post('/complete-payment', { sessionId });\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.error || 'Error completando el pago');\r\n      }\r\n\r\n      return response.data;\r\n    } catch (error) {\r\n      if (error.response) {\r\n        throw new Error(error.response.data?.error || 'Error completando el pago');\r\n      } else if (error.request) {\r\n        throw new Error('Error de conexión al completar el pago');\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Obtiene el estado de una sesión de pago\r\n   * @param {string} sessionId - ID de la sesión\r\n   * @returns {Promise<Object>} Estado de la sesión\r\n   */\r\n  async getSessionStatus(sessionId) {\r\n    try {\r\n      if (!sessionId) {\r\n        throw new Error('Se requiere el ID de la sesión');\r\n      }\r\n\r\n      const response = await api.get(`/session/${sessionId}`);\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.error || 'Sesión no encontrada');\r\n      }\r\n\r\n      return response.data;\r\n    } catch (error) {\r\n      if (error.response?.status === 404) {\r\n        throw new Error('Sesión no encontrada o expirada');\r\n      } else if (error.response) {\r\n        throw new Error(error.response.data?.error || 'Error obteniendo estado de sesión');\r\n      } else if (error.request) {\r\n        throw new Error('Error de conexión');\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Cancela una sesión de pago\r\n   * @param {string} sessionId - ID de la sesión a cancelar\r\n   * @returns {Promise<Object>} Confirmación de cancelación\r\n   */\r\n  async cancelSession(sessionId) {\r\n    try {\r\n      if (!sessionId) {\r\n        throw new Error('Se requiere el ID de la sesión');\r\n      }\r\n\r\n      const response = await api.delete(`/session/${sessionId}`);\r\n\r\n      if (!response.data.success) {\r\n        throw new Error(response.data.error || 'Error cancelando la sesión');\r\n      }\r\n\r\n      return response.data;\r\n    } catch (error) {\r\n      if (error.response?.status === 404) {\r\n        // Si la sesión ya no existe, consideramos que está cancelada\r\n        return { success: true, message: 'Sesión ya cancelada o expirada' };\r\n      } else if (error.response) {\r\n        throw new Error(error.response.data?.error || 'Error cancelando la sesión');\r\n      } else if (error.request) {\r\n        throw new Error('Error de conexión al cancelar');\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Valida una URL de wallet\r\n   * @param {string} walletUrl - URL a validar\r\n   * @returns {boolean} true si es válida\r\n   */\r\n  validateWalletUrl(walletUrl) {\r\n    try {\r\n      const url = new URL(walletUrl);\r\n      return url.protocol === 'https:' && url.hostname.includes('interledger');\r\n    } catch {\r\n      return false;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Formatea una cantidad para mostrar\r\n   * @param {string|number} amount - Cantidad a formatear\r\n   * @param {string} assetCode - Código de la moneda (opcional)\r\n   * @returns {string} Cantidad formateada\r\n   */\r\n  formatAmount(amount, assetCode = '') {\r\n    try {\r\n      const num = Number(amount);\r\n      if (isNaN(num)) return amount;\r\n      \r\n      return new Intl.NumberFormat('es-ES', {\r\n        minimumFractionDigits: 0,\r\n        maximumFractionDigits: 2\r\n      }).format(num) + (assetCode ? ` ${assetCode}` : '');\r\n    } catch {\r\n      return amount.toString();\r\n    }\r\n  }\r\n};\r\n\r\nexport default paymentService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}